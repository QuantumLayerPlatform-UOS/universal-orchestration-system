package temporal

import (
	"encoding/json"
	"fmt"
	"time"

	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/workflow"
	"go.uber.org/zap"

	"orchestrator/internal/models"
)

// TaskExecutionWorkflow handles the execution of tasks generated by intent processing
func (w *WorkflowEngine) TaskExecutionWorkflow(ctx workflow.Context, wf *models.Workflow) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting task execution workflow with meta-agent integration", "workflowID", wf.ID)

	// Set workflow options with appropriate timeouts
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 30 * time.Minute,
		HeartbeatTimeout:    2 * time.Minute,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    time.Second,
			BackoffCoefficient: 2.0,
			MaximumInterval:    5 * time.Minute,
			MaximumAttempts:    3,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// Step 1: Parse workflow input to get tasks and intent result
	var workflowInput TaskExecutionInput
	if err := json.Unmarshal(wf.Input, &workflowInput); err != nil {
		return fmt.Errorf("failed to parse workflow input: %w", err)
	}

	logger.Info("Processing tasks from intent result", 
		"taskCount", len(workflowInput.Tasks),
		"projectID", workflowInput.ProjectID)

	// Step 2: Process each task using meta-agent system
	var taskResults []TaskExecutionResult
	for _, task := range workflowInput.Tasks {
		logger.Info("Processing task", 
			"taskID", task.ID,
			"taskType", task.Type,
			"title", task.Title)

		// Find or create suitable agent for the task using meta-agent system
		var agent AgentInfo
		err := workflow.ExecuteActivity(ctx, "MetaAgentFindOrCreateAgentForTaskActivity", task).Get(ctx, &agent)
		if err != nil {
			logger.Error("Failed to find/create agent for task", 
				zap.String("taskID", task.ID),
				zap.Error(err))
			
			// Record failed task
			taskResults = append(taskResults, TaskExecutionResult{
				TaskID: task.ID,
				Status: "failed",
				Error:  fmt.Sprintf("Agent selection failed: %v", err),
			})
			continue
		}

		logger.Info("Agent selected for task", 
			"taskID", task.ID,
			"agentID", agent.ID,
			"agentType", agent.Type)

		// Execute task with agent using enhanced meta-agent execution
		var taskResult TaskExecutionResult
		err = workflow.ExecuteActivity(ctx, "MetaAgentExecuteTaskWithAgentActivity", task, agent).Get(ctx, &taskResult)
		if err != nil {
			logger.Error("Task execution failed", 
				zap.String("taskID", task.ID),
				zap.String("agentID", agent.ID),
				zap.Error(err))
			
			taskResult = TaskExecutionResult{
				TaskID:  task.ID,
				Status:  "failed",
				Error:   fmt.Sprintf("Execution failed: %v", err),
				AgentID: agent.ID,
			}
		}

		taskResults = append(taskResults, taskResult)

		// Update progress
		// Note: RecordHeartbeat is for activities, not workflows
	}

	// Step 3: Aggregate results and artifacts
	var aggregatedResult AggregatedTaskResult
	err := workflow.ExecuteActivity(ctx, "AggregateTaskResultsActivity", taskResults).Get(ctx, &aggregatedResult)
	if err != nil {
		logger.Error("Failed to aggregate results", zap.Error(err))
	}

	// Step 4: Store artifacts if any
	if len(aggregatedResult.Artifacts) > 0 {
		err = workflow.ExecuteActivity(ctx, "StoreArtifactsActivity", 
			workflowInput.ProjectID, aggregatedResult.Artifacts).Get(ctx, nil)
		if err != nil {
			logger.Error("Failed to store artifacts", zap.Error(err))
		}
	}

	// Step 5: Performance optimization for agents (async)
	if len(taskResults) > 0 {
		// Group results by agent for performance analysis
		agentResults := make(map[string][]TaskExecutionResult)
		for _, result := range taskResults {
			if result.AgentID != "" {
				agentResults[result.AgentID] = append(agentResults[result.AgentID], result)
			}
		}

		// Request performance optimization for each agent (non-blocking)
		for agentID, results := range agentResults {
			if len(results) >= 2 { // Only optimize if we have enough data
				workflow.ExecuteActivity(ctx, "MetaAgentOptimizeAgentPerformanceActivity", agentID, results)
				// Don't wait for completion - this is for future optimization
			}
		}
	}

	// Update workflow output
	outputData, _ := json.Marshal(aggregatedResult)
	wf.Output = outputData

	// Count unique agents used
	uniqueAgents := 0
	if len(taskResults) > 0 {
		agentMap := make(map[string]bool)
		for _, result := range taskResults {
			if result.AgentID != "" {
				agentMap[result.AgentID] = true
			}
		}
		uniqueAgents = len(agentMap)
	}

	logger.Info("Task execution workflow completed with meta-agent integration", 
		"workflowID", wf.ID,
		"totalTasks", len(taskResults),
		"successfulTasks", aggregatedResult.SuccessfulTasks,
		"uniqueAgentsUsed", uniqueAgents,
		"totalArtifacts", len(aggregatedResult.Artifacts))

	return nil
}

// Types for task execution workflow

type TaskExecutionInput struct {
	ProjectID    string                 `json:"project_id"`
	IntentResult IntentAnalysisResult   `json:"intent_result"`
	Tasks        []Task                 `json:"tasks"`
	Context      map[string]interface{} `json:"context"`
}

type Task struct {
	ID                    string                 `json:"id"`
	Title                 string                 `json:"title"`
	Description           string                 `json:"description"`
	Type                  string                 `json:"type"`
	Priority              string                 `json:"priority"`
	Complexity            string                 `json:"complexity"`
	EstimatedHours        float64                `json:"estimated_hours"`
	Dependencies          []string               `json:"dependencies"`
	Tags                  []string               `json:"tags"`
	AcceptanceCriteria    []string               `json:"acceptance_criteria"`
	TechnicalRequirements map[string]interface{} `json:"technical_requirements"`
}

type TaskExecutionResult struct {
	TaskID    string                 `json:"task_id"`
	AgentID   string                 `json:"agent_id"`
	Status    string                 `json:"status"`
	Output    map[string]interface{} `json:"output"`
	Artifacts []Artifact             `json:"artifacts"`
	Error     string                 `json:"error,omitempty"`
	StartTime time.Time              `json:"start_time"`
	EndTime   time.Time              `json:"end_time"`
	Duration  time.Duration          `json:"duration"`
}

type Artifact struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Type        string    `json:"type"`
	Content     string    `json:"content"`
	Path        string    `json:"path"`
	Size        int64     `json:"size"`
	ContentType string    `json:"content_type"`
	CreatedAt   time.Time `json:"created_at"`
}

type AggregatedTaskResult struct {
	Status          string                 `json:"status"`
	TotalTasks      int                    `json:"total_tasks"`
	SuccessfulTasks int                    `json:"successful_tasks"`
	FailedTasks     int                    `json:"failed_tasks"`
	TaskResults     []TaskExecutionResult  `json:"task_results"`
	Artifacts       []Artifact             `json:"artifacts"`
	Summary         string                 `json:"summary"`
	Metadata        map[string]interface{} `json:"metadata"`
}